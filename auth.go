package tcpsocks

import (
	"encoding/hex"
	"fmt"
	"os"
	"strings"

	"tcpsocks/internal/keydata"
)

//go:generate go run ./internal/keygen -out ./internal/keydata/keydata.go

// BuildPSKHex can be provided at build time via:
//
//	go build -ldflags "-X tcpsocks.BuildPSKHex=<64 hex chars>"
//
// Key source priority (highest first):
//  1. SOCKS_PSK_HEX (runtime)
//  2. BuildPSKHex (build-time)
//  3. internal/keydata.DefaultPSKHex (generated by `go generate`)
var BuildPSKHex string

var (
	psk   [32]byte
	pskOK bool
)

// LoadPSK loads a 32-byte PSK from hex (64 characters).
// If no key is configured, HasPSK() returns false and LoadPSK returns nil.
func LoadPSK() error {
	s := strings.TrimSpace(os.Getenv("SOCKS_PSK_HEX"))
	if s == "" {
		s = strings.TrimSpace(BuildPSKHex)
	}
	if s == "" {
		s = strings.TrimSpace(keydata.DefaultPSKHex)
	}
	if s == "" {
		pskOK = false
		return nil
	}
	b, err := hex.DecodeString(s)
	if err != nil || len(b) != 32 {
		return fmt.Errorf("invalid SOCKS_PSK_HEX/BuildPSKHex: expected 64 hex chars (32 bytes)")
	}
	copy(psk[:], b)
	pskOK = true
	return nil
}

// HasPSK reports whether a PSK was successfully loaded.
func HasPSK() bool { return pskOK }

// PSK returns the loaded PSK by value. Use PSK()[:] to get a []byte view.
// If HasPSK() is false, it returns a zeroed array.
func PSK() [32]byte { return psk }
