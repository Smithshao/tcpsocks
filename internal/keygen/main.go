package main

import (
	"crypto/rand"
	"encoding/hex"
	"flag"
	"fmt"
	"os"
	"path/filepath"
	"strings"
)

func fatalf(format string, args ...any) {
	fmt.Fprintf(os.Stderr, "keygen: "+format+"\n", args...)
	os.Exit(1)
}

func main() {
	outPath := flag.String("out", "internal/keydata/keydata.go", "output file path")
	psk := flag.String("psk", "", "custom PSK hex (64 chars) to embed")
	flag.Parse()

	keyHex := strings.TrimSpace(*psk)
	if keyHex == "" {
		keyHex = strings.TrimSpace(os.Getenv("PSK_HEX"))
	}
	if keyHex == "" {
		keyHex = strings.TrimSpace(os.Getenv("TCPSOCKS_PSK_HEX"))
	}

	auto := false
	if keyHex == "" {
		b := make([]byte, 32)
		if _, err := rand.Read(b); err != nil {
			fatalf("rand.Read: %v", err)
		}
		keyHex = hex.EncodeToString(b)
		auto = true

		// If no key is provided, generate one and print it to stdout.
		fmt.Fprintln(os.Stdout, keyHex)
	} else {
		b, err := hex.DecodeString(keyHex)
		if err != nil || len(b) != 32 {
			fatalf("invalid PSK: expected 64 hex chars (32 bytes)")
		}
		_ = b
	}

	if err := os.MkdirAll(filepath.Dir(*outPath), 0755); err != nil {
		fatalf("MkdirAll: %v", err)
	}

	content := fmt.Sprintf(`// Code generated by tcpsocks/internal/keygen; DO NOT EDIT.
package keydata

// DefaultPSKHex is a 32-byte PSK in hex form (64 characters) embedded into the binary
// when BuildPSKHex is not provided. Empty string means "not set".
const DefaultPSKHex = "%s"

// AutoGenerated is true when the key was generated automatically (go generate without a custom key).
const AutoGenerated = %v
`, keyHex, auto)

	if err := os.WriteFile(*outPath, []byte(content), 0644); err != nil {
		fatalf("WriteFile: %v", err)
	}
}
